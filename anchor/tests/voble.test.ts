/**
 * Voble Ephemeral Rollups Integration Tests
 * 
 * Tests the complete flow of:
 * 1. Create profile on base layer
 * 2. Buy ticket and create session on base layer
 * 3. Delegate session to ER (separate instruction)
 * 4. Submit guesses on ER (gasless, fast)
 * 5. Complete game on base layer
 * 6. Undelegate session from ER (separate instruction)
 * 
 * Key Concepts:
 * - provider: Base layer (Solana devnet)
 * - providerEphemeralRollup: ER layer (MagicBlock ER)
 * - Delegation uses #[delegate] macro (auto-generates accounts)
 * - Undelegation uses #[commit] macro (auto-injects magic accounts)
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Voble } from "../target/types/voble";
import { PublicKey, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { expect } from "chai";
// Note: Delegation PDAs will be derived manually
// MagicBlock Delegation Program ID
const DELEGATION_PROGRAM_ID = new PublicKey("DELeGGvXpWV2fqJUhqcF5ZSYMS4JTLjteaAMARRSaeSh");

describe("voble", () => {
  // Configure the client to use the local cluster
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  // Configure Ephemeral Rollup provider
  const providerEphemeralRollup = new anchor.AnchorProvider(
    new anchor.web3.Connection("https://devnet-as.magicblock.app/", {
      wsEndpoint: "wss://devnet.magicblock.app/",
    }),
    provider.wallet,
    { commitment: "confirmed" }
  );

  // ER Validator
  const ER_VALIDATOR = new PublicKey(
    "MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57"
  ); // Asia ER Validator

  const program = anchor.workspace.Voble as Program<Voble>;
  const payer = provider.wallet as anchor.Wallet;

  // Test accounts
  let userProfilePda: PublicKey;
  let sessionPda: PublicKey;
  let globalConfigPda: PublicKey;
  let leaderboardPda: PublicKey;
  let dailyPrizeVault: PublicKey;
  let weeklyPrizeVault: PublicKey;
  let monthlyPrizeVault: PublicKey;
  let platformVault: PublicKey;
  
  // No longer need delegation accounts - handled by #[delegate] macro

  const username = "TestPlayer";
  const periodId = "2025-01-20"; // Test period ID

  before(async () => {
    console.log("üéÆ Setting up Voble test environment...");
    console.log("Payer:", payer.publicKey.toBase58());

    // Derive PDAs
    [userProfilePda] = PublicKey.findProgramAddressSync(
      [Buffer.from("user_profile"), payer.publicKey.toBuffer()],
      program.programId
    );

    [sessionPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("session"), payer.publicKey.toBuffer()],
      program.programId
    );

    [globalConfigPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("global_config_v2")],
      program.programId
    );

    [leaderboardPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("leaderboard"), Buffer.from(periodId), Buffer.from("daily")],
      program.programId
    );

    // Derive prize vault PDAs
    [dailyPrizeVault] = PublicKey.findProgramAddressSync(
      [Buffer.from("daily_prize_vault")],
      program.programId
    );

    [weeklyPrizeVault] = PublicKey.findProgramAddressSync(
      [Buffer.from("weekly_prize_vault")],
      program.programId
    );

    [monthlyPrizeVault] = PublicKey.findProgramAddressSync(
      [Buffer.from("monthly_prize_vault")],
      program.programId
    );

    [platformVault] = PublicKey.findProgramAddressSync(
      [Buffer.from("platform_vault")],
      program.programId
    );

    // Delegation accounts are now auto-generated by #[delegate] macro

    console.log("User Profile PDA:", userProfilePda.toBase58());
    console.log("Session PDA:", sessionPda.toBase58());
    console.log("Global Config PDA:", globalConfigPda.toBase58());
    console.log("Leaderboard PDA:", leaderboardPda.toBase58());
    console.log("Daily Prize Vault:", dailyPrizeVault.toBase58());
    console.log("Weekly Prize Vault:", weeklyPrizeVault.toBase58());
    console.log("Monthly Prize Vault:", monthlyPrizeVault.toBase58());
    console.log("Platform Vault:", platformVault.toBase58());
  });

  it("Initializes global config", async () => {
    console.log("\n‚öôÔ∏è  Test: Initialize Global Config");

    try {
      // Check if config already exists
      const existingConfig = await provider.connection.getAccountInfo(globalConfigPda);
      if (existingConfig) {
        console.log("‚ö†Ô∏è  Global config already exists, skipping initialization");
        const config = await program.account.globalConfig.fetch(globalConfigPda);
        console.log("‚úÖ Using existing config:", {
          ticketPrice: config.ticketPrice.toString(),
          paused: config.paused,
        });
        return;
      }

      const tx = await program.methods
        .initializeGlobalConfig(
          new anchor.BN(1_000_000), // 0.001 SOL ticket price
          4000, // 40% daily
          3000, // 30% weekly
          2000, // 20% monthly
          1000, // 10% platform revenue (total = 100%)
          [5000, 3000, 2000] // Winner splits: 50%, 30%, 20%
        )
        .accounts({
          authority: payer.publicKey,
          globalConfig: globalConfigPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      console.log("‚úÖ Global config initialized. Tx:", tx);

      // Verify config
      const config = await program.account.globalConfig.fetch(globalConfigPda);
      console.log("‚úÖ Config verified:", {
        ticketPrice: config.ticketPrice.toString(),
        dailySplit: config.prizeSplitDaily,
        weeklySplit: config.prizeSplitWeekly,
        monthlySplit: config.prizeSplitMonthly,
      });
    } catch (error) {
      console.error("‚ùå Error initializing config:", error);
      throw error;
    }
  });

  it("Creates user profile", async () => {
    console.log("\nüìù Test: Create User Profile");

    try {
      // Check if profile already exists
      const existingProfile = await provider.connection.getAccountInfo(userProfilePda);
      if (existingProfile) {
        console.log("‚ö†Ô∏è  Profile already exists, skipping creation");
        const profile = await program.account.userProfile.fetch(userProfilePda);
        console.log("‚úÖ Using existing profile:", {
          username: profile.username,
          player: profile.player.toBase58(),
        });
        return;
      }

      const tx = await program.methods
        .initializeUserProfile(username)
        .accounts({
          payer: payer.publicKey,
          userProfile: userProfilePda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      console.log("‚úÖ Profile created. Tx:", tx);

      // Fetch and verify profile
      const profile = await program.account.userProfile.fetch(userProfilePda);
      expect(profile.username).to.equal(username);
      expect(profile.totalGamesPlayed).to.equal(0);
      expect(profile.gamesWon).to.equal(0);
      console.log("‚úÖ Profile verified:", {
        username: profile.username,
        player: profile.player.toBase58(),
      });
    } catch (error) {
      console.error("‚ùå Error creating profile:", error);
      throw error;
    }
  });

  it("Buys ticket and starts game (creates session)", async () => {
    console.log("\nüé´ Test: Buy Ticket and Start Game");

    try {
      // Check session account before delegation
      console.log("üìä Checking session state before delegation...");
      let sessionAccountInfo = await provider.connection.getAccountInfo(sessionPda);
      if (sessionAccountInfo) {
        console.log("‚ö†Ô∏è  Session already exists, owner:", sessionAccountInfo.owner.toBase58());
        console.log("   Data length:", sessionAccountInfo.data.length);
        console.log("   Lamports:", sessionAccountInfo.lamports);
        // If session exists, skip this test
        console.log("‚ö†Ô∏è  Skipping test - session already exists from previous run");
        return;
      } else {
        console.log("‚úÖ Session doesn't exist yet (will be created)");
      }

      // Airdrop some SOL if needed
      const balance = await provider.connection.getBalance(payer.publicKey);
      console.log(`üí∞ Current balance: ${balance / LAMPORTS_PER_SOL} SOL`);
      if (balance < 2 * LAMPORTS_PER_SOL) {
        console.log("üí∞ Airdropping 5 SOL...");
        await provider.connection.requestAirdrop(payer.publicKey, 5 * LAMPORTS_PER_SOL);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait longer for airdrop
        const newBalance = await provider.connection.getBalance(payer.publicKey);
        console.log(`‚úÖ New balance: ${newBalance / LAMPORTS_PER_SOL} SOL`);
      }

      console.log("üé´ Buying ticket and creating session...");
      
      // Buy ticket and create session (no delegation yet)
      const txHash = await program.methods
        .buyTicketAndStartGame(periodId)
        .accounts({
          payer: payer.publicKey,
          userProfile: userProfilePda,
          session: sessionPda,
          globalConfig: globalConfigPda,
          dailyPrizeVault: dailyPrizeVault,
          weeklyPrizeVault: weeklyPrizeVault,
          monthlyPrizeVault: monthlyPrizeVault,
          platformVault: platformVault,
          systemProgram: SystemProgram.programId,
        })
        .rpc({ skipPreflight: true });

      console.log("‚úÖ Ticket purchased and session created. Tx:", txHash);

      // Wait for transaction confirmation
      await provider.connection.confirmTransaction(txHash, "confirmed");

      // Verify session was created
      console.log("\nüîç Verifying session creation...");
      sessionAccountInfo = await provider.connection.getAccountInfo(sessionPda);
      
      if (!sessionAccountInfo) {
        throw new Error("Session account was not created!");
      }

      console.log("‚úÖ Session account created");
      console.log("   Owner:", sessionAccountInfo.owner.toBase58());
      console.log("   Expected owner (program):", program.programId.toBase58());
      
      // Now delegate session to ER
      console.log("\n‚ö° Delegating session to ER...");
      const delegateTx = await program.methods
        .delegateSession()
        .accounts({
          payer: payer.publicKey,
          pda: sessionPda,
        })
        .remainingAccounts([
          { pubkey: ER_VALIDATOR, isSigner: false, isWritable: false }
        ])
        .rpc();
      
      console.log("‚úÖ Session delegated to ER. Tx:", delegateTx);

      // Wait for delegation to be processed and session to be cloned to ER
      console.log("\n‚è≥ Waiting for session to be cloned to ER...");
      await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds
      
      // Verify session is available on ER
      try {
        const sessionOnER = await providerEphemeralRollup.connection.getAccountInfo(sessionPda);
        if (sessionOnER) {
          console.log("‚úÖ Session cloned to ER successfully");
          console.log("   Owner on ER:", sessionOnER.owner.toBase58());
        } else {
          console.log("‚ö†Ô∏è  Session not yet on ER, may need more time");
        }
      } catch (err) {
        console.log("‚ö†Ô∏è  Could not check ER session status:", err);
      }

      // Fetch and verify session data
      const session = await program.account.sessionAccount.fetch(sessionPda);
      expect(session.player.toBase58()).to.equal(payer.publicKey.toBase58());
      expect(session.periodId).to.equal(periodId);
      expect(session.guessesUsed).to.equal(0);
      
      console.log("\n‚úÖ Session data verified:");
      console.log("   Player:", session.player.toBase58());
      console.log("   Period ID:", session.periodId);
      console.log("   Guesses used:", session.guessesUsed);
      console.log("   Target word hash:", Buffer.from(session.targetWordHash).toString('hex').slice(0, 16) + "...");
      
    } catch (error) {
      console.error("‚ùå Error buying ticket:", error);
      throw error;
    }
  });

  it("Submits guesses (on Ephemeral Rollup)", async () => {
    console.log("\nüéØ Test: Submit Guesses on ER");

    const guesses = ["HELLO", "WORLD", "TESTS"];

    try {
      console.log("üìù Submitting multiple guesses to ER...");
      
      for (let i = 0; i < guesses.length; i++) {
        const guess = guesses[i];
        console.log(`\n   Guess ${i + 1}: ${guess}`);
        
        // Build transaction for ER
        // Note: Only session is needed (on ER)
        let tx = await program.methods
          .submitGuess(periodId, guess)
          .accountsStrict({
            session: sessionPda,
          })
          .transaction();

        // Debug: Log transaction accounts
        console.log("   Transaction accounts:", tx.instructions[0].keys.map(k => ({
          pubkey: k.pubkey.toBase58(),
          isSigner: k.isSigner,
          isWritable: k.isWritable
        })));

        // Sign and send on ER (gasless, fast!)
        tx.feePayer = providerEphemeralRollup.wallet.publicKey;
        tx.recentBlockhash = (
          await providerEphemeralRollup.connection.getLatestBlockhash()
        ).blockhash;
        tx = await providerEphemeralRollup.wallet.signTransaction(tx);
        const txHash = await providerEphemeralRollup.sendAndConfirm(tx);

        console.log(`   ‚úÖ Submitted on ER. Tx: ${txHash.slice(0, 16)}...`);
        
        // Small delay between guesses
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      console.log("\nüîç Verifying session state after guesses...");
      
      // Fetch session from ER (use ER connection!)
      const sessionAccountInfo = await providerEphemeralRollup.connection.getAccountInfo(sessionPda);
      const session = await program.account.sessionAccount.fetch(sessionPda, "confirmed");
      
      expect(session.guessesUsed).to.equal(guesses.length);
      console.log("‚úÖ All guesses recorded on ER:");
      console.log("   Guesses used:", session.guessesUsed);
      console.log("   Is solved:", session.isSolved);
      console.log("   Guesses:", session.guesses.filter(g => g !== null).map(g => g.guess));
      
      // Verify session is still on ER (owner should be delegation program or ER validator)
      console.log("\nüìä Session ownership:");
      console.log("   Current owner:", sessionAccountInfo?.owner.toBase58());
      console.log("   Program ID:", program.programId.toBase58());
      console.log("   ‚úÖ Is on ER:", sessionAccountInfo?.owner.toBase58() !== program.programId.toBase58());
      
    } catch (error) {
      console.error("‚ùå Error submitting guesses:", error);
      throw error;
    }
  });

  it("Completes game (undelegates session from ER)", async () => {
    console.log("\nüèÅ Test: Complete Game and Undelegate from ER");

    try {
      // Check session ownership before completion
      console.log("üìä Session state before completion:");
      let sessionAccountInfo = await provider.connection.getAccountInfo(sessionPda);
      const ownerBeforeComplete = sessionAccountInfo?.owner.toBase58();
      console.log("   Owner before:", ownerBeforeComplete);
      console.log("   Is on ER:", ownerBeforeComplete !== program.programId.toBase58());

      console.log("\nüèÅ Completing game and undelegating session...");
      
      const tx = await program.methods
        .completeVobleGame(periodId)
        .accounts({
          payer: payer.publicKey,
          userProfile: userProfilePda,
          session: sessionPda,
          leaderboard: leaderboardPda,
          systemProgram: SystemProgram.programId,
          // Add magic context accounts if using Magic Actions
        })
        .rpc();

      console.log("‚úÖ Game completed. Tx:", tx);

      // Wait for confirmation
      await provider.connection.confirmTransaction(tx, "confirmed");
      await new Promise(resolve => setTimeout(resolve, 2000)); // Extra wait for undelegation

      // Verify session was undelegated
      console.log("\nüîç Verifying session undelegation...");
      sessionAccountInfo = await provider.connection.getAccountInfo(sessionPda);
      const ownerAfterComplete = sessionAccountInfo?.owner.toBase58();
      
      console.log("üìä Session state after completion:");
      console.log("   Owner after:", ownerAfterComplete);
      console.log("   Expected (program):", program.programId.toBase58());
      console.log("   Is undelegated:", ownerAfterComplete === program.programId.toBase58());

      if (ownerAfterComplete === program.programId.toBase58()) {
        console.log("‚úÖ Session successfully undelegated from ER!");
      } else {
        console.log("‚ö†Ô∏è  Session might still be on ER (check delegation status)");
      }

      // Verify session data was committed
      const session = await program.account.sessionAccount.fetch(sessionPda);
      console.log("\n‚úÖ Final session state:");
      console.log("   Guesses used:", session.guessesUsed);
      console.log("   Is solved:", session.isSolved);
      console.log("   Score:", session.score);
      console.log("   Completed:", session.completed);

      // Fetch and verify profile was updated
      const profile = await program.account.userProfile.fetch(userProfilePda);
      expect(profile.totalGamesPlayed).to.be.greaterThan(0);
      
      console.log("\n‚úÖ Profile updated:");
      console.log("   Total games played:", profile.totalGamesPlayed);
      console.log("   Games won:", profile.gamesWon);
      console.log("   Current streak:", profile.currentStreak);
      console.log("   Total score:", profile.totalScore.toString());
      console.log("   Best score:", profile.bestScore);

      // Delegation cleanup is handled automatically by the #[delegate] macro
      console.log("\n‚úÖ Session undelegated successfully");
      
    } catch (error) {
      console.error("‚ùå Error completing game:", error);
      throw error;
    }
  });

  it("Fetches user profile", async () => {
    console.log("\nüë§ Test: Fetch User Profile");

    try {
      const profile = await program.account.userProfile.fetch(userProfilePda);
      
      console.log("‚úÖ Profile fetched:", {
        username: profile.username,
        totalGamesPlayed: profile.totalGamesPlayed,
        gamesWon: profile.gamesWon,
        currentStreak: profile.currentStreak,
        maxStreak: profile.maxStreak,
        totalScore: profile.totalScore.toString(),
        bestScore: profile.bestScore,
      });

      expect(profile.player.toBase58()).to.equal(payer.publicKey.toBase58());
    } catch (error) {
      console.error("‚ùå Error fetching profile:", error);
      throw error;
    }
  });

  it("Fetches leaderboard", async () => {
    console.log("\nüèÜ Test: Fetch Leaderboard");

    try {
      const leaderboard = await program.account.periodLeaderboard.fetch(leaderboardPda);
      
      console.log("‚úÖ Leaderboard fetched:", {
        periodId: leaderboard.periodId,
        totalPlayers: leaderboard.totalPlayers,
        entriesCount: leaderboard.entries.length,
        finalized: leaderboard.finalized,
      });

      if (leaderboard.entries.length > 0) {
        console.log("Top entry:", {
          player: leaderboard.entries[0].player.toBase58(),
          score: leaderboard.entries[0].score,
          username: leaderboard.entries[0].username,
        });
      }
    } catch (error) {
      console.error("‚ùå Error fetching leaderboard:", error);
      console.log("‚ö†Ô∏è  Leaderboard might not exist yet");
    }
  });
});
